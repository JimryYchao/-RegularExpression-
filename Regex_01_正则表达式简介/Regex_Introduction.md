# Regex Introduce

- [Regex Introduce](#regex-introduce)
  - [第1章 Regex 简介](#第1章-regex-简介)
    - [1.1 简介说明](#11-简介说明)
    - [1.2 Regex 引擎](#12-regex-引擎)
    - [1.3 Regex 常规作用](#13-regex-常规作用)
    - [1.4 Regex 语法规则](#14-regex-语法规则)
  - [第2章 Regex 结构元素](#第2章-regex-结构元素)
    - [2.1 普通字符](#21-普通字符)
    - [2.2 非打印字符](#22-非打印字符)
    - [2.3 特殊字符](#23-特殊字符)
    - [2.4 限定符](#24-限定符)
    - [2.5 定位符](#25-定位符)
    - [2.6 选择](#26-选择)
    - [2.7 反向引用](#27-反向引用)
    - [2.8 其它元字符](#28-其它元字符)
    - [2.9 其他构造](#29-其他构造)
  - [第3章 Regex 分组构造](#第3章-regex-分组构造)
    - [3.1 捕获组与非捕获组](#31-捕获组与非捕获组)
    - [3.2 平衡组](#32-平衡组)
    - [3.3 组选项](#33-组选项)
    - [3.4 断言分组(非捕获)](#34-断言分组非捕获)
    - [3.5 原子组(非回溯表达式)](#35-原子组非回溯表达式)
  - [第4章 运算符优先级](#第4章-运算符优先级)
  - [第5章 替换构造](#第5章-替换构造)
  - [第6章 替代](#第6章-替代)

---
## 第1章 Regex 简介

### 1.1 简介说明

- **正则表达式** ***(Regular Expression)*** 是对字符串操作的一种逻辑公式

- **正则表达式**，又称规则表达式，是一种文本模式，通常用来检索、替换和控制文本。主要包括 a 到 z 的字母以及一些特殊的元字符。 

---
### 1.2 Regex 引擎

> 正则表达式的引擎主要分为两大类：一种是DFA，一种是NFA，后来又出现了两者的合并类 POSIX NFA。

1.  **DFA引擎**在线性时状态下执行，可以确保匹配最长的可能的字符串。它不能匹配具有反向引用的模式；因为它不构造显示扩展，所以它不可以捕获子表达式。

2.  **NFA引擎**以 特定扩展以获得成功的匹配，所以它可以捕获子表达式匹配和匹配的反向引用，但是执行速度可能因此被拖慢。

3.  **POSIX NFA 引擎**与传统的 NFA 引擎类似，不同点在于除非已经找到了可能的最长的匹配，否则它将一直回溯。因此POSIX NFA 引擎的速度慢于传统的 NFA 引擎。

> NFA以表达式为主导，DFA以文本为主导。一般而论，DFA引擎则搜索更快一些，但是NFA以表达式为主导，反而更容易操纵搜索对象格式。

---
### 1.3 Regex 常规作用

> 通过使用正则表达式，可以：

1. 测试字符串内的模式。(例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。)

2. 替换文本。( 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。)

3. 基于模式匹配从字符串中提取子字符串。( 可以查找文档内或输入域内特定的文本。)

>  例如:  您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

---
### 1.4 Regex 语法规则

> <strong>正则表达式(regular expression)</strong> 描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。

1. 列目录时，dir \*.txt 或 ls \*.txt 中的 \*.txt 就不是一个正则表达式,因为这里*与正则式的*的含义是不同的。

2. 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

>**正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。**

---
## 第2章 Regex 结构元素

### 2.1 普通字符

- 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

---
### 2.2 非打印字符

- 在Regex中赋予特殊意义的显式指定元字符

```regex
    \cx     匹配由x指明的控制字符 (\cM 匹配 Control-M 或回车符)
                # x 的值必须为 A-Za-z
    \f      换页符 (等价 \x0c 和 \cL)
    \n      换行符 (等价 \x0a 和 \cJ)
    \r      回车符 (等价 \x0d 和 \cM)
    \s      任何空白符 (等价 [ \f\r\n\t\v]) 包括空格
    \S      任何非空白符 (等价 [^ \f\r\n\t\v]) 不包括空格
    \t      制表符 (等价 \x09 和 \cI)
    \v      垂直制表符 (等价 \x0b 和 \cK)
    \e      与转义符 \u001B 匹配
```

---
### 2.3 特殊字符

- 表示在正则表达式中具有特殊含义的字符

```regex
    $       匹配输入字符串的结尾位置, \$ 表示匹配自身原义 $ 
                ('d+$' 表示多个数字并以数字为字符串结尾)
   ( )      标记子 Regex 表达式
    *       匹配前面的子表达式零次或多次, (等价于 '{0,}')
    +       匹配前面的子表达式一次或多次, (等价于 '{1,}')
    .       匹配除换行符 \n 之外的任何单字符
   [ ]      范围表达式, 表示匹配的字符为限定范围字符组的其中一个 
                ('[A-Z]' 表示大字英文字母)
    ?       匹配前面的子表达式零次或一次, 或指明一个非贪婪限定符, 用在限定符之后表示惰性
                ('d*?' 表示惰性匹配数字字符, 尽可能少的匹配)
    \       将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符
    ^       匹配输入字符串的开始位置, 或在范围表达式开头表示取反范围
                ('[^A-Z]' 表示非 A-Z 字符)
   { }      限定表达式, 表示匹配前方的子表达式匹配次数
                ('{1,2}' 表示匹配 1 到 2 次)
    |       指明两项表达式之间的一个选择
                ('(\d+|[A-Za-z]+)' 表示要么是数字字符串, 要么是字母字符串)
```

---
### 2.4 限定符

- 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。

```regex
    *       匹配前面的子表达式零次或多次 
                ('zo*' 能匹配 "z" 以及 "zoo"。\* 等价于 {0,})
    +       匹配前面的子表达式一次或多次
                ('zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z")
    ?       匹配前面的子表达式零次或一次
                ("do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 
                 "doxy" 中的 "do" 。? 等价于 {0,1})
   {n}      匹配确定的 n 次 ('A{2}' 匹配 'BAA' 非 'BAAA')
   {n,}     至少匹配n 次
   {n,m}    最少匹配 n 次且最多匹配 m 次  

   *?       匹配上一个元素零次或多次，但次数尽可能少 (惰性非贪婪)
   +?	    匹配上一个元素一次或多次，但次数尽可能少
   ??	    匹配上一个元素零次或一次，但次数尽可能少
   {n}?	    匹配前面的元素恰好 n 次
   {n,}?	匹配上一个元素至少 n 次，但次数尽可能少
   {n,m}?	匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少
```

---
### 2.5 定位符

- 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

```regex
    ^       匹配输入字符串开始的位置 (常规以行为单位, 遇 \n\r 停止)
    $       匹配输入字符串结尾的位置 (常规以行为单位, 遇 \n\r 停止)
    \A      匹配字符串的开始位置
    \b      匹配一个字符边界 ('\bJS\b' 表示与 'JS' 匹配)
    \B      非字符边界匹配 ('\BZOO\B' 表示与 'AZOOA' 中的 'ZOO' 匹配)
    \G      匹配出现在上一个匹配结束的地方 
                ('\G\(\d\)' 匹配"(1)(3)(5)[7](9)" 中的 "(1)"、"(3)" 和 "(5)")
    \z      匹配在字符串的末尾, 或出现在字符串末尾的 \n 之前
    \Z      匹配字符串的末尾
```

---
### 2.6 选择

- 用圆括号将所有选择项括起来，相邻的选择项之间用 | 分隔。但用圆括号会有一个副作用，是相关的匹配对象会被缓存 (捕捉)，此时可用 **?：** 放在第一个选项前来消除这种副作用 (表示非捕捉组)。

---
### 2.7 反向引用

```regex
    \num        	后向引用。 匹配编号子表达式的值
    \k<name>	    命名后向引用。 匹配命名表达式的值 ('(?<char>\w)\k<char>')
```

- 对一个正则表达式模式或部分模式两边添加圆括号【'(subregex)'】将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。
- 缓冲区编号从 1 开始，每个缓冲区都可以使用 '\n' 访问 (\1 到 \9)
- 向后引用时, 使用 \num 表示将对应的子表达式复用
- 对于命名组的反向引用, 通过\k<name> 引用

> 反向引用举例一

- 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：

```html
Is is the cost of of gasoline going up up?
```

- 上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：

```regex
/\b([a-z]+) \1\b/gi
```

1. 捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。

2. 正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。字边界元字符确保只检测整个单词。否则，诸如"is issued"或"this is"之类的词组将不能正确地被此表达式识别。

3. 正则表达式后面的全局标记 (g) 指示，将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。

4. 表达式的结尾处的不区分大小写 (i) 标记指定不区分大小写。多行标记指定换行符的两边可能出现潜在的匹配。

> 反向引用举例二

- 反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页 / 路径：

```html
http://www.example.site:80/html/html-tutorial.html
```

- 下面的正则表达式提供该功能：

```regex
/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/
```

1. 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。

2. 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 / 或 : 之外的一个或多个字符。

3. 第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。

4. 第四个括号子表达式捕获 Web 地址指定的路径和/或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

- 第一个括号子表达式包含"http"
- 第二个括号子表达式包含"www.example.site"
- 第三个括号子表达式包含":80"
- 第四个括号子表达式包含"/html/html-tutorial.html"

---
### 2.8 其它元字符

```regex
    \d      数字字符 ('[0-9]')
    \D      非数字字符 ('[^0-9]')
    \w      包括下划线的任何单词字符 ('[A-Za-z0-9_]')
    \W      任何非单词字符 ('[^A-Za-z0-9_]')
    \num    匹配组向后引用, num 表示第 num 组子表达式
    \k<name> / \k'name'      表示反向引用命名捕获组

    \p{name}      表示包含某 name 的 Unicode 字符集,
                        P：标点字符。
                        L：字母；
                        M：标记符号（一般不会单独出现）；
                        Z：分隔符（比如空格、换行等）；
                        S：符号（比如数学符号、货币符号等）；
                        N：数字（比如阿拉伯数字、罗马数字等）；
                        C：其他字符。
    \P{name}      表示不包含某 name 的 Unicode 字符集
    \nnn    使用八进制表示形式指定字符（nnn 由二位或三位数字组成）
                ('\w\040\w' 匹配 "a bc d" 中的 "a b" 和 "c d")
    \xnn    使用十六进制表示形式指定字符（nn 恰好由两位数字组成）
                ('\w\x20\w' 匹配 "a bc d" 中的 "a b" 和 "c d")
    \unnnn  使用十六进制表示形式匹配 Unicode 字符（由 nnnn 正确表示的四位数)
```

---
### 2.9 其他构造

1. 内联选项 ：(?imnsx-imnsx)    i--无视大小写, m--多行模式, n--仅显式捕获, s--单行模式, x--忽略未转义空格,并允许表达式 # 注释

2. 内联注释 ：(?# comment) 构造可用于在正则表达式中添加内联注释 ；

3. 行尾注释 ："exp(?x) # comment",  数字符号 (#) 标记 x 模式注释，即从正则表达式模式末尾的未转义 # 字符开始一直延续到行末。 若要使用此构造，必须启用 x 选项（通过内联选项）例如, "(\d{5})(?x) # This is a comment"

---
## 第3章 Regex 分组构造

### 3.1 捕获组与非捕获组

```regex
    (pattern)       非命名捕获组, 匹配并捕获这一匹配, 捕获的结果保存在临时缓存区, 
                        通过 Matches 集合获取匹配的结果, 默认数字分组命名
                        0 表示完整表达式

    (?<name>pattern)
    (?'name'pattern)     命名捕获组, 匹配并捕获, 通过 name 来获取相应的匹配组结果

    (?:pattern)     匹配不捕获, 不保存结果, 一般用于验证结果
```

---
### 3.2 平衡组

```regex
    (?<name1-name2>pattern)     平衡组捕获，name2 表示平衡组前命名捕获组，
            平衡组定义删除 name2 的定义并在 name1 中保存 name2 和 name1 之间的间隔
    string str = "<A><B><C><D><E>";
    Regex pattern = new Regex("((?<open><)\w(?<close-open>>))+");

    该 'close' 平衡组匹配 A B C D E
```

---
### 3.3 组选项

```regex
    (?inmsx-inmsx:pattern)      定义该分组选项
        (?insmx:((?<open><)\w(?<close-open>>))+?)

        i (IgnoreCase)          使用不区分大小写的匹配
        n (ExplicitCapture)     不捕获未命名的组
        m (Multiline)           使用多行模式，其中 ^ 和 $ 匹配每行的开头和末尾
                                    （不是输入字符串的开头和末尾）
        s (Singleline)          使用单行模式，其中的句号 (.) 匹配每个字符
                                    （而不是除了 \n 以外的每个字符)
        x (IgnorePatternWhitespace)    
                                从模式中排除保留的空白并启用数字符号 # 后的注释
    
其他选项
    None               使用默认行为
    Compiled           将正则表达式编译为程序集
    RightToLeft        更改搜索方向。 搜索是从右向左而不是从左向右进行
    ECMAScript         为表达式启用符合 ECMAScript 的行为
    CultureInvariant   忽略语言的区域性差异
```

> 指定选项方法一

```csharp
string pattern = @"d \w+ \s";
string input = "Dogs are decidedly good pets.";
//忽略大小写与表达式留白
RegexOptions options = RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace;

foreach (Match match in Regex.Matches(input, pattern, options))
   Console.WriteLine("'{0}// found at index {1}.", match.Value, match.Index);
// The example displays the following output:
//    'Dogs // found at index 0.
//    'decidedly // found at index 9.
```

> 指定选项方式二

```csharp
string pattern = @"(?ix) d \w+ \s";
string input = "Dogs are decidedly good pets.";

// ?ix = IgnoreCase + IgnorePatternWhitespace
foreach (Match match in Regex.Matches(input, pattern))
   Console.WriteLine("'{0}// found at index {1}.", match.Value, match.Index);
// The example displays the following output:
//    'Dogs // found at index 0.
//    'decidedly // found at index 9.
```

> 指定选项方法三: 包含语法 (?imnsx-imnsx:exp) // -代表关闭一些选项

```csharp
//分组构造中的内联选项
// 选项带符号代表关闭, 无符号表示打开
string pattern = @"\b(?imnsx-mns: d \w+)\s";
string input = "Dogs are decidedly good pets.";


foreach (Match match in Regex.Matches(input, pattern))
   Console.WriteLine("'{0}// found at index {1}.", match.Value, match.Index);
// The example displays the following output:
//    'Dogs // found at index 0.
//    'decidedly // found at index 9.
```

>确定选项：

  - 可以确定向 Regex 对象提供哪些选项，在通过检索只读 Regex.Options 属性的值将其实例化时。 
     
- 要测试除 RegexOptions.None 之外的任何选项的存在，使用 Regex.Options 属性的值和需要的 RegexOptions 值执行 AND 运算。 然后测试结果是否等于该 RegexOptions 值。 下面的示例测试是否设置了 RegexOptions.IgnoreCase 选项。

```csharp
if ((rgx.Options & RegexOptions.IgnoreCase) == RegexOptions.IgnoreCase)
{
    Console.WriteLine("Case-insensitive pattern comparison.");
}
else
{
    Console.WriteLine("Case-sensitive pattern comparison");
}
```

- 要测试 RegexOptions.None，确定 Regex.Options 属性的值是否等于 RegexOptions.None

```csharp
if (rgx.Options == RegexOptions.None)
{
    Console.WriteLine("No options have been set");
}
```


---
### 3.4 断言分组(非捕获)

```regex
    (?=pattern)         匹配满足表达式前面的部分【零宽度正预测先行断言】
    (?!pattern)         匹配对象后面的部分不匹配该表达式【零宽度负预测先行断言】
    (?<=pattern)        匹配满足表达式后面的部分【零宽度正回顾后发断言】
    (?<!pattern)        匹配对象前面的部分不匹配该表达式【零宽度负回顾后发断言】
```

---
### 3.5 原子组(非回溯表达式)

```regex
    (?>pattern)         该子表达式仅与可由该子表达式单独匹配的字符串匹配；
            子表达式不会尝试与基于该子表达式的字符串和任何该子表达式之后的子表达式匹配
```

---
## 第4章 运算符优先级

1. 正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
2. 相同优先级的从左到右进行运算，不同优先级的运算先高后低。

---
## 第5章 替换构造

```regex
    (regex_A|regex_B)       表示满足 A 或 B 表达式
    (?(pattern)regex_A|regex_B)     表示当满足 pattern 时匹配 A 表达式
                                    当不满足 pattern 时匹配 B 表达式
    
    (?(name)yes|no)
    (?(number)yes|no)       基于有效的捕获组的条件匹配
                 yes 是当 name 或 number 具有匹配项时要匹配的表达式；
                 no 是当不具有匹配项时要匹配的可选表达式。
```

---
## 第6章 替代

```regex
    $number     包括替换字符串中的由 number 标识的捕获组所匹配的最后一个子字符串
                    其中 number 是一个十进制值
    ${name}     包括替换字符串中由(?<name>pattern)指定的命名组所匹配的最后一个子字符串
    $$          包括替换字符串中的单个 $ 文本
    $&          包括替换字符串中整个匹配项的副本
    $`          包括替换字符串中的匹配项前的输入字符串的所有文本
    $'          包括替换字符串中的匹配项后的输入字符串的所有文本
    $+          包括在替换字符串中捕获的最后一个组
    $_          包括替换字符串中的整个输入字符串
```

> 替换元素与替换模式：

- 替换是替换模式中唯一可识别的特殊构造。 与任何字符匹配的其他正则表达式语言元素（包括字符转义和句点 (.)）均不受支持。 
- 同样，替换语言元素只能在替换模式中识别，并且在正则表达式模式中永远无效。替换的原则, 未被任何表达式捕捉的对象保持不变。
- 例如  "(?i:(?<2>\d)+(?<3>[\w ])*)+" 表达式下对"(((3^2smA22kFske asdQAWK", 替换元素为"${2},", 输出结果为"(((3,^2," 。
 
> 替换已编号的组：

 - "\$1" 代表的是由num标识的捕获组所匹配的子字符串对象, ''\$0"代表完整表达式匹配的字符串对象, "(\$1)" 表示 (子字符串)。
 "" 中没有\$\<name>替换字符时代表要将完整表达式字符串对象完整替换掉, 例如 "666" 作为Regex.Replace()方法的替换元素, 将把每一个匹配到的对象替换成 "666"
      
> 替换命名组：

- \$\<name> 作为替换命名组捕获的字符串组。

> 其他替换构造

- \$\$ 在替换字符串元素中用于代表单个\$, 
- \$& = \$0, 
- \$` 代表每个\$0前的所有文本, 
- \$' 代表每个\$0后的所有文本, 
- \$+ 表示正则表达式中的最后一个捕获组, 
- \$_ 代表完整的 input 字符串

> 案例

```csharp
public static void Main()
{
    //仅有一个捕获组，且<1>为最后一个捕获组,因此 $1 = ${1} = $+, $&=$0
    string pattern = @"\p{Sc}*(?<1>\d+[.,]?\d*)\p{Sc}*";
    string replacement = "|$`|";//"","666","$1","$1#","@$+","$5","${1}$$","|$`|"
    string input = "$16.32 12.19 £16.29 €18.29  €18,29";

    string result = Regex.Replace(input, pattern, replacement);
    Console.WriteLine(result);

    // The example displays the following output:
    //     ""       "       ", 长空字符串
    //     "666"    "666 666 666 666  666"
    //     "$1"     "16.32 12.19 16.29 18.29  18,29"
    //     "$1#"    "16.32# 12.19# 16.29# 18.29#  18,29#"
    //     "@$+"    "@16.32 @12.19 @16.29 @18.29  @18,29"
    //     "$5"     "$5 $5 $5 $5  $5"   不存在捕获组5,整体表示原义
    //     "${1}$$" "16.32$ 12.19$ 16.29$ 18.29$  18,29$"
    //     "|$`|"   "|| |$16.32 | |$16.32 12.19 | |$16.32 12.19
    //              ￡16.29 |  |$16.32 12.19 ￡16.29 €18.29  |"
    //
    //  正则表达式中,存在空匹配项,当表达式有 *,{0,},{0,n},? 等,就会存在0次匹配的情况,此时该
    //  捕获组的对象便是空匹配项,空匹配项不代表是空字符
}
```